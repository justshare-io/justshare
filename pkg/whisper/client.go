package whisper

import (
	"bufio"
	"bytes"
	"context"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"github.com/google/wire"
	genapi "github.com/lunabrain-ai/lunabrain/gen"
	"github.com/lunabrain-ai/lunabrain/pkg/store/bucket"
	"github.com/pkg/errors"
	"github.com/protoflow-labs/protoflow/pkg/openai"
	"github.com/reactivex/rxgo/v2"
	"github.com/rs/zerolog/log"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"os/exec"
)

const (
	transModel = "models/ggml-base.en.bin"
)

type Client struct {
	config    openai.Config
	fileStore *bucket.Bucket
}

var ProviderSet = wire.NewSet(
	NewConfig,
	NewClient,
)

func NewClient(
	config openai.Config,
	fileStore *bucket.Bucket,
) *Client {
	return &Client{
		config:    config,
		fileStore: fileStore,
	}
}

func (a *Client) Transcribe(filePath string) error {
	// Create a buffer to store our request body
	var requestBody bytes.Buffer

	// Create a multipart writer
	writer := multipart.NewWriter(&requestBody)

	// Open the file
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Create a form file writer for the file field
	formFileWriter, err := writer.CreateFormFile("file", file.Name())
	if err != nil {
		return err
	}

	// Copy the file content to the form file writer
	_, err = io.Copy(formFileWriter, file)
	if err != nil {
		return err
	}

	// Add the model field
	err = writer.WriteField("model", "whisper-1")
	if err != nil {
		return err
	}

	// Close the multipart writer to finalize the body
	err = writer.Close()
	if err != nil {
		return err
	}

	// Create a new HTTP request
	req, err := http.NewRequest("POST", "https://api.openai.com/v1/audio/transcriptions", &requestBody)
	if err != nil {
		return err
	}

	// Set the content type generated by the multipart writer
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Add the authorization header
	req.Header.Set("Authorization", "Bearer "+a.config.APIKey)

	// Send the HTTP request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Print the response
	fmt.Printf("Status: %s\n", resp.Status)

	// For testing, read and print the response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	fmt.Printf("Response: %s\n", respBody)

	return nil
}

type WAVHeader struct {
	RiffID        [4]byte
	RiffSize      uint32
	WaveID        [4]byte
	FmtID         [4]byte
	FmtSize       uint32
	AudioFormat   uint16
	NumChannels   uint16
	SampleRate    uint32
	ByteRate      uint32
	BlockAlign    uint16
	BitsPerSample uint16
	DataID        [4]byte
	DataSize      uint32
}

func splitWAVFile(chunks int, filePath string) error {
	// Open the input file
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Read the WAV header
	var header WAVHeader
	err = binary.Read(file, binary.LittleEndian, &header)
	if err != nil {
		return err
	}

	// Calculate bytes per sample and samples per chunk
	bytesPerSample := int(header.BlockAlign)
	samplesPerChunk := chunks / bytesPerSample

	buffer := make([]byte, bytesPerSample*samplesPerChunk)

	chunkCounter := 0
	for {
		// Read a chunk of samples from the input file
		n, err := file.Read(buffer)
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}

		// Create a new output file for the chunk
		outputFilePath := fmt.Sprintf("/path/to/output/chunk_%d.wav", chunkCounter)
		outputFile, err := os.Create(outputFilePath)
		if err != nil {
			return err
		}

		// Write the header to the output file
		header.DataSize = uint32(n)
		err = binary.Write(outputFile, binary.LittleEndian, &header)
		if err != nil {
			outputFile.Close()
			return err
		}

		// Write the chunk data to the output file
		_, err = outputFile.Write(buffer[:n])
		if err != nil {
			outputFile.Close()
			return err
		}

		outputFile.Close()
		chunkCounter++
	}

	return nil
}

func (a *Client) StreamTranscription(ctx context.Context, file string, captureDevice int32) rxgo.Observable {
	return rxgo.Create([]rxgo.Producer{func(ctx context.Context, next chan<- rxgo.Item) {
		cmd := exec.Command("third_party/whisper.cpp/stream")
		_, err := os.Stat(transModel)
		if err != nil {
			next <- rxgo.Error(errors.Wrapf(err, "failed to stat model %s", transModel))
			return
		}

		if file != "" {
			cmd.Args = append(cmd.Args, "main", "-owts", "-f", file)
		} else {
			cmd.Args = append(
				cmd.Args,
				"stream",
				// TODO breadchris offer selection for input stream
				"-c", fmt.Sprintf("%d", captureDevice),
			)
		}
		cmd.Args = append(
			cmd.Args,
			"-m", transModel,
		)

		log.Debug().
			Str("cmd", cmd.String()).
			Msg("running stream")
		stdout, err := cmd.StdoutPipe()
		if err != nil {
			next <- rxgo.Error(err)
			return
		}
		stderr, err := cmd.StderrPipe()
		if err != nil {
			next <- rxgo.Error(err)
			return
		}

		stdoutScan := bufio.NewScanner(stdout)
		go func() {
			for stdoutScan.Scan() {
				var seg genapi.Segment
				if err := json.Unmarshal([]byte(stdoutScan.Text()), &seg); err != nil {
					next <- rxgo.Error(err)
					continue
				}
				next <- rxgo.Of(&seg)
			}
		}()

		stderrScan := bufio.NewScanner(stderr)
		go func() {
			for stderrScan.Scan() {
				// next <- rxgo.Of(stderrScan.Text())
				log.Debug().Str("stderr", stderrScan.Text()).Msg("stream")
			}
		}()

		err = cmd.Start()
		if err != nil {
			next <- rxgo.Error(err)
			return
		}

		go func() {
			<-ctx.Done()
			log.Info().Msg("killing stream")
			cmd.Process.Kill()
		}()

		err = cmd.Wait()
		if err != nil {
			next <- rxgo.Error(err)
			return
		}
	}}, rxgo.WithContext(ctx))
}
