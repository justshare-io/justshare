// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: content/content.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Content_RelateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parent: String = String()

  public var children: [String] = []

  public var connect: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Sources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sources: [Content_EnumeratedSource] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_EnumeratedSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: Content_Source {
    get {return _source ?? Content_Source()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  public var displayContent: [Content_DisplayContent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Content_Source? = nil
}

public struct Content_DisplayContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var description_p: String = String()

  public var type: String = String()

  public var content: Content_Content {
    get {return _content ?? Content_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: Content_Content? = nil
}

public struct Content_Source {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var type: Content_Source.OneOf_Type? = nil

  public var server: Content_Server {
    get {
      if case .server(let v)? = type {return v}
      return Content_Server()
    }
    set {type = .server(newValue)}
  }

  public var folder: Content_Folder {
    get {
      if case .folder(let v)? = type {return v}
      return Content_Folder()
    }
    set {type = .folder(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case server(Content_Server)
    case folder(Content_Folder)

  #if !swift(>=4.1)
    public static func ==(lhs: Content_Source.OneOf_Type, rhs: Content_Source.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.server, .server): return {
        guard case .server(let l) = lhs, case .server(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.folder, .folder): return {
        guard case .folder(let l) = lhs, case .folder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Content_Server {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Folder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_SetTagsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contentID: String = String()

  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_TagRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Tags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tags: [Content_Tag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Tag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var subTags: [Content_Tag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_ContentIDs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contentIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Contents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Content_Content {
    get {return _content ?? Content_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var tags: [String] = []

  public var related: [Content_Content] = []

  public var parents: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: Content_Content? = nil
}

public struct Content_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var page: UInt32 = 0

  public var contentID: String = String()

  public var groupID: String = String()

  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Results {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var storedContent: [Content_StoredContent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_StoredContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Content_Content {
    get {return _storage._content ?? Content_Content()}
    set {_uniqueStorage()._content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return _storage._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {_uniqueStorage()._content = nil}

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var related: [Content_Content] {
    get {return _storage._related}
    set {_uniqueStorage()._related = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var image: String {
    get {return _storage._image}
    set {_uniqueStorage()._image = newValue}
  }

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var user: User_User {
    get {return _storage._user ?? User_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var tags: [Content_Tag] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var preview: String {
    get {return _storage._preview}
    set {_uniqueStorage()._preview = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Content_Edge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: String = String()

  public var to: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Content has data and metadata
public struct Content_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tags: [String] = []

  public var createdAt: String = String()

  public var uri: String = String()

  public var id: String = String()

  public var type: Content_Content.OneOf_Type? = nil

  public var data: Content_Data {
    get {
      if case .data(let v)? = type {return v}
      return Content_Data()
    }
    set {type = .data(newValue)}
  }

  public var normalized: Content_Normalized {
    get {
      if case .normalized(let v)? = type {return v}
      return Content_Normalized()
    }
    set {type = .normalized(newValue)}
  }

  public var transformed: Content_Transformed {
    get {
      if case .transformed(let v)? = type {return v}
      return Content_Transformed()
    }
    set {type = .transformed(newValue)}
  }

  public var post: Content_Post {
    get {
      if case .post(let v)? = type {return v}
      return Content_Post()
    }
    set {type = .post(newValue)}
  }

  public var site: Content_Site {
    get {
      if case .site(let v)? = type {return v}
      return Content_Site()
    }
    set {type = .site(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case data(Content_Data)
    case normalized(Content_Normalized)
    case transformed(Content_Transformed)
    case post(Content_Post)
    case site(Content_Site)

  #if !swift(>=4.1)
    public static func ==(lhs: Content_Content.OneOf_Type, rhs: Content_Content.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.normalized, .normalized): return {
        guard case .normalized(let l) = lhs, case .normalized(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transformed, .transformed): return {
        guard case .transformed(let l) = lhs, case .transformed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.post, .post): return {
        guard case .post(let l) = lhs, case .post(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.site, .site): return {
        guard case .site(let l) = lhs, case .site(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Content_Post {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var summary: String = String()

  public var content: String = String()

  public var authors: [String] = []

  public var draft: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_GitRepo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Content_Data.OneOf_Type? = nil

  public var text: Content_Text {
    get {
      if case .text(let v)? = type {return v}
      return Content_Text()
    }
    set {type = .text(newValue)}
  }

  public var file: Content_File {
    get {
      if case .file(let v)? = type {return v}
      return Content_File()
    }
    set {type = .file(newValue)}
  }

  public var url: Content_URL {
    get {
      if case .url(let v)? = type {return v}
      return Content_URL()
    }
    set {type = .url(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case text(Content_Text)
    case file(Content_File)
    case url(Content_URL)

  #if !swift(>=4.1)
    public static func ==(lhs: Content_Data.OneOf_Type, rhs: Content_Data.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.url, .url): return {
        guard case .url(let l) = lhs, case .url(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Content_Normalized {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Content_Normalized.OneOf_Type? = nil

  public var article: Content_Article {
    get {
      if case .article(let v)? = type {return v}
      return Content_Article()
    }
    set {type = .article(newValue)}
  }

  public var html: Content_HTML {
    get {
      if case .html(let v)? = type {return v}
      return Content_HTML()
    }
    set {type = .html(newValue)}
  }

  public var transcript: Content_Transcript {
    get {
      if case .transcript(let v)? = type {return v}
      return Content_Transcript()
    }
    set {type = .transcript(newValue)}
  }

  public var readme: Content_ReadMe {
    get {
      if case .readme(let v)? = type {return v}
      return Content_ReadMe()
    }
    set {type = .readme(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case article(Content_Article)
    case html(Content_HTML)
    case transcript(Content_Transcript)
    case readme(Content_ReadMe)

  #if !swift(>=4.1)
    public static func ==(lhs: Content_Normalized.OneOf_Type, rhs: Content_Normalized.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.article, .article): return {
        guard case .article(let l) = lhs, case .article(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.html, .html): return {
        guard case .html(let l) = lhs, case .html(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transcript, .transcript): return {
        guard case .transcript(let l) = lhs, case .transcript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readme, .readme): return {
        guard case .readme(let l) = lhs, case .readme(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Content_Transformed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Content_Transformed.OneOf_Type? = nil

  public var summary: Content_Summary {
    get {
      if case .summary(let v)? = type {return v}
      return Content_Summary()
    }
    set {type = .summary(newValue)}
  }

  public var categories: Content_Categories {
    get {
      if case .categories(let v)? = type {return v}
      return Content_Categories()
    }
    set {type = .categories(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case summary(Content_Summary)
    case categories(Content_Categories)

  #if !swift(>=4.1)
    public static func ==(lhs: Content_Transformed.OneOf_Type, rhs: Content_Transformed.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.summary, .summary): return {
        guard case .summary(let l) = lhs, case .summary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.categories, .categories): return {
        guard case .categories(let l) = lhs, case .categories(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Content_Article {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var author: String = String()

  public var length: Int32 = 0

  public var excerpt: String = String()

  public var siteName: String = String()

  public var image: String = String()

  public var favicon: String = String()

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_HTML {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var html: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_ReadMe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Summary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var summary: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Categories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var categories: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var file: String = String()

  public var data: Data = Data()

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Text {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_URL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var crawl: Bool = false

  public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt32 = 0

  public var startTime: UInt64 = 0

  public var endTime: UInt64 = 0

  public var text: String = String()

  public var p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Segment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var num: UInt32 = 0

  public var tokens: [Content_Token] = []

  public var text: String = String()

  public var startTime: UInt64 = 0

  public var endTime: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_Transcript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var segments: [Content_Segment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_GRPCTypeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msg: SwiftProtobuf.Google_Protobuf_DescriptorProto {
    get {return _msg ?? SwiftProtobuf.Google_Protobuf_DescriptorProto()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  public var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  public mutating func clearMsg() {self._msg = nil}

  public var descLookup: Dictionary<String,SwiftProtobuf.Google_Protobuf_DescriptorProto> = [:]

  public var enumLookup: Dictionary<String,SwiftProtobuf.Google_Protobuf_EnumDescriptorProto> = [:]

  public var packageName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _msg: SwiftProtobuf.Google_Protobuf_DescriptorProto? = nil
}

public struct Content_Site {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hugoConfig: Content_HugoConfig {
    get {return _hugoConfig ?? Content_HugoConfig()}
    set {_hugoConfig = newValue}
  }
  /// Returns true if `hugoConfig` has been explicitly set.
  public var hasHugoConfig: Bool {return self._hugoConfig != nil}
  /// Clears the value of `hugoConfig`. Subsequent reads from it will return its default value.
  public mutating func clearHugoConfig() {self._hugoConfig = nil}

  public var postTags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hugoConfig: Content_HugoConfig? = nil
}

public struct Content_HugoConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var theme: String = String()

  public var baseURL: String = String()

  public var title: String = String()

  public var params: Content_ParamsConfig {
    get {return _params ?? Content_ParamsConfig()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Content_ParamsConfig? = nil
}

public struct Content_ParamsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var env: String {
    get {return _storage._env}
    set {_uniqueStorage()._env = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var author: String {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  public var defaultTheme: String {
    get {return _storage._defaultTheme}
    set {_uniqueStorage()._defaultTheme = newValue}
  }

  public var showShareButtons: Bool {
    get {return _storage._showShareButtons}
    set {_uniqueStorage()._showShareButtons = newValue}
  }

  public var showReadingTime: Bool {
    get {return _storage._showReadingTime}
    set {_uniqueStorage()._showReadingTime = newValue}
  }

  public var displayFullLangName: Bool {
    get {return _storage._displayFullLangName}
    set {_uniqueStorage()._displayFullLangName = newValue}
  }

  public var showPostNavLinks: Bool {
    get {return _storage._showPostNavLinks}
    set {_uniqueStorage()._showPostNavLinks = newValue}
  }

  public var showBreadCrumbs: Bool {
    get {return _storage._showBreadCrumbs}
    set {_uniqueStorage()._showBreadCrumbs = newValue}
  }

  public var showCodeCopyButtons: Bool {
    get {return _storage._showCodeCopyButtons}
    set {_uniqueStorage()._showCodeCopyButtons = newValue}
  }

  public var showRssButtonInSectionTermList: Bool {
    get {return _storage._showRssButtonInSectionTermList}
    set {_uniqueStorage()._showRssButtonInSectionTermList = newValue}
  }

  public var showAllPagesInArchive: Bool {
    get {return _storage._showAllPagesInArchive}
    set {_uniqueStorage()._showAllPagesInArchive = newValue}
  }

  public var showPageNums: Bool {
    get {return _storage._showPageNums}
    set {_uniqueStorage()._showPageNums = newValue}
  }

  public var showToc: Bool {
    get {return _storage._showToc}
    set {_uniqueStorage()._showToc = newValue}
  }

  public var images: [String] {
    get {return _storage._images}
    set {_uniqueStorage()._images = newValue}
  }

  public var profileMode: Content_ProfileModeConfig {
    get {return _storage._profileMode ?? Content_ProfileModeConfig()}
    set {_uniqueStorage()._profileMode = newValue}
  }
  /// Returns true if `profileMode` has been explicitly set.
  public var hasProfileMode: Bool {return _storage._profileMode != nil}
  /// Clears the value of `profileMode`. Subsequent reads from it will return its default value.
  public mutating func clearProfileMode() {_uniqueStorage()._profileMode = nil}

  public var homeInfoParams: Content_HomeInfoParamsConfig {
    get {return _storage._homeInfoParams ?? Content_HomeInfoParamsConfig()}
    set {_uniqueStorage()._homeInfoParams = newValue}
  }
  /// Returns true if `homeInfoParams` has been explicitly set.
  public var hasHomeInfoParams: Bool {return _storage._homeInfoParams != nil}
  /// Clears the value of `homeInfoParams`. Subsequent reads from it will return its default value.
  public mutating func clearHomeInfoParams() {_uniqueStorage()._homeInfoParams = nil}

  public var socialIcons: [Content_SocialIconConfig] {
    get {return _storage._socialIcons}
    set {_uniqueStorage()._socialIcons = newValue}
  }

  public var editPost: Content_EditPostConfig {
    get {return _storage._editPost ?? Content_EditPostConfig()}
    set {_uniqueStorage()._editPost = newValue}
  }
  /// Returns true if `editPost` has been explicitly set.
  public var hasEditPost: Bool {return _storage._editPost != nil}
  /// Clears the value of `editPost`. Subsequent reads from it will return its default value.
  public mutating func clearEditPost() {_uniqueStorage()._editPost = nil}

  public var assets: Content_AssetsConfig {
    get {return _storage._assets ?? Content_AssetsConfig()}
    set {_uniqueStorage()._assets = newValue}
  }
  /// Returns true if `assets` has been explicitly set.
  public var hasAssets: Bool {return _storage._assets != nil}
  /// Clears the value of `assets`. Subsequent reads from it will return its default value.
  public mutating func clearAssets() {_uniqueStorage()._assets = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Content_ProfileModeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enabled: Bool = false

  public var title: String = String()

  public var imageURL: String = String()

  public var imageTitle: String = String()

  public var buttons: [Content_ButtonConfig] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_ButtonConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_HomeInfoParamsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_SocialIconConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var title: String = String()

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_EditPostConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var text: String = String()

  public var appendFilePath: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Content_AssetsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var disableHljs: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Content_RelateRequest: @unchecked Sendable {}
extension Content_Sources: @unchecked Sendable {}
extension Content_EnumeratedSource: @unchecked Sendable {}
extension Content_DisplayContent: @unchecked Sendable {}
extension Content_Source: @unchecked Sendable {}
extension Content_Source.OneOf_Type: @unchecked Sendable {}
extension Content_Server: @unchecked Sendable {}
extension Content_Folder: @unchecked Sendable {}
extension Content_SetTagsRequest: @unchecked Sendable {}
extension Content_TagRequest: @unchecked Sendable {}
extension Content_Tags: @unchecked Sendable {}
extension Content_Tag: @unchecked Sendable {}
extension Content_ContentIDs: @unchecked Sendable {}
extension Content_Contents: @unchecked Sendable {}
extension Content_Query: @unchecked Sendable {}
extension Content_Results: @unchecked Sendable {}
extension Content_StoredContent: @unchecked Sendable {}
extension Content_Edge: @unchecked Sendable {}
extension Content_Content: @unchecked Sendable {}
extension Content_Content.OneOf_Type: @unchecked Sendable {}
extension Content_Post: @unchecked Sendable {}
extension Content_GitRepo: @unchecked Sendable {}
extension Content_Data: @unchecked Sendable {}
extension Content_Data.OneOf_Type: @unchecked Sendable {}
extension Content_Normalized: @unchecked Sendable {}
extension Content_Normalized.OneOf_Type: @unchecked Sendable {}
extension Content_Transformed: @unchecked Sendable {}
extension Content_Transformed.OneOf_Type: @unchecked Sendable {}
extension Content_Article: @unchecked Sendable {}
extension Content_HTML: @unchecked Sendable {}
extension Content_ReadMe: @unchecked Sendable {}
extension Content_Summary: @unchecked Sendable {}
extension Content_Categories: @unchecked Sendable {}
extension Content_File: @unchecked Sendable {}
extension Content_Text: @unchecked Sendable {}
extension Content_URL: @unchecked Sendable {}
extension Content_Token: @unchecked Sendable {}
extension Content_Segment: @unchecked Sendable {}
extension Content_Transcript: @unchecked Sendable {}
extension Content_GRPCTypeInfo: @unchecked Sendable {}
extension Content_Site: @unchecked Sendable {}
extension Content_HugoConfig: @unchecked Sendable {}
extension Content_ParamsConfig: @unchecked Sendable {}
extension Content_ProfileModeConfig: @unchecked Sendable {}
extension Content_ButtonConfig: @unchecked Sendable {}
extension Content_HomeInfoParamsConfig: @unchecked Sendable {}
extension Content_SocialIconConfig: @unchecked Sendable {}
extension Content_EditPostConfig: @unchecked Sendable {}
extension Content_AssetsConfig: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "content"

extension Content_RelateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "children"),
    3: .same(proto: "connect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.children) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.connect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedStringField(value: self.children, fieldNumber: 2)
    }
    if self.connect != false {
      try visitor.visitSingularBoolField(value: self.connect, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_RelateRequest, rhs: Content_RelateRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.children != rhs.children {return false}
    if lhs.connect != rhs.connect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Sources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sources"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sources) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sources, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Sources, rhs: Content_Sources) -> Bool {
    if lhs.sources != rhs.sources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_EnumeratedSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnumeratedSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "display_content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.displayContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.displayContent.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.displayContent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_EnumeratedSource, rhs: Content_EnumeratedSource) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.displayContent != rhs.displayContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_DisplayContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisplayContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "type"),
    4: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_DisplayContent, rhs: Content_DisplayContent) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.type != rhs.type {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Source"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "server"),
    3: .same(proto: "folder"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Content_Server?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .server(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .server(v)
        }
      }()
      case 3: try {
        var v: Content_Folder?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .folder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .folder(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.type {
    case .server?: try {
      guard case .server(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .folder?: try {
      guard case .folder(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Source, rhs: Content_Source) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Server: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Server"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Server, rhs: Content_Server) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Folder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Folder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Folder, rhs: Content_Folder) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_SetTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetTagsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_id"),
    2: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 1)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_SetTagsRequest, rhs: Content_SetTagsRequest) -> Bool {
    if lhs.contentID != rhs.contentID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_TagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_TagRequest, rhs: Content_TagRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Tags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Tags, rhs: Content_Tags) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "sub_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.subTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.subTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subTags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Tag, rhs: Content_Tag) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.subTags != rhs.subTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_ContentIDs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentIDs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.contentIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.contentIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_ContentIDs, rhs: Content_ContentIDs) -> Bool {
    if lhs.contentIds != rhs.contentIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Contents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "tags"),
    3: .same(proto: "related"),
    4: .same(proto: "parents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.related) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.parents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 2)
    }
    if !self.related.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.related, fieldNumber: 3)
    }
    if !self.parents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parents, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Contents, rhs: Content_Contents) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.related != rhs.related {return false}
    if lhs.parents != rhs.parents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .same(proto: "page"),
    3: .same(proto: "contentID"),
    4: .same(proto: "groupID"),
    5: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 3)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 4)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Query, rhs: Content_Query) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.page != rhs.page {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Results: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Results"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storedContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.storedContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storedContent.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storedContent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Results, rhs: Content_Results) -> Bool {
    if lhs.storedContent != rhs.storedContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_StoredContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoredContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "id"),
    3: .same(proto: "related"),
    4: .same(proto: "title"),
    5: .same(proto: "description"),
    6: .same(proto: "image"),
    7: .same(proto: "url"),
    9: .same(proto: "user"),
    10: .same(proto: "tags"),
    11: .same(proto: "preview"),
  ]

  fileprivate class _StorageClass {
    var _content: Content_Content? = nil
    var _id: String = String()
    var _related: [Content_Content] = []
    var _title: String = String()
    var _description_p: String = String()
    var _image: String = String()
    var _url: String = String()
    var _user: User_User? = nil
    var _tags: [Content_Tag] = []
    var _preview: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
      _id = source._id
      _related = source._related
      _title = source._title
      _description_p = source._description_p
      _image = source._image
      _url = source._url
      _user = source._user
      _tags = source._tags
      _preview = source._preview
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._content) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._related) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._image) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._preview) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if !_storage._related.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._related, fieldNumber: 3)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      if !_storage._image.isEmpty {
        try visitor.visitSingularStringField(value: _storage._image, fieldNumber: 6)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 7)
      }
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 10)
      }
      if !_storage._preview.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preview, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_StoredContent, rhs: Content_StoredContent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._content != rhs_storage._content {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._related != rhs_storage._related {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._preview != rhs_storage._preview {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Edge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Edge, rhs: Content_Edge) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "uri"),
    4: .same(proto: "id"),
    6: .same(proto: "data"),
    7: .same(proto: "normalized"),
    8: .same(proto: "transformed"),
    9: .same(proto: "post"),
    10: .same(proto: "site"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 6: try {
        var v: Content_Data?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .data(v)
        }
      }()
      case 7: try {
        var v: Content_Normalized?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .normalized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .normalized(v)
        }
      }()
      case 8: try {
        var v: Content_Transformed?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .transformed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .transformed(v)
        }
      }()
      case 9: try {
        var v: Content_Post?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .post(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .post(v)
        }
      }()
      case 10: try {
        var v: Content_Site?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .site(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .site(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 1)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 2)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 3)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 4)
    }
    switch self.type {
    case .data?: try {
      guard case .data(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .normalized?: try {
      guard case .normalized(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .transformed?: try {
      guard case .transformed(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .post?: try {
      guard case .post(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .site?: try {
      guard case .site(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Content, rhs: Content_Content) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Post"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "summary"),
    3: .same(proto: "content"),
    4: .same(proto: "authors"),
    6: .same(proto: "draft"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.authors) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.draft) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    if !self.authors.isEmpty {
      try visitor.visitRepeatedStringField(value: self.authors, fieldNumber: 4)
    }
    if self.draft != false {
      try visitor.visitSingularBoolField(value: self.draft, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Post, rhs: Content_Post) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.content != rhs.content {return false}
    if lhs.authors != rhs.authors {return false}
    if lhs.draft != rhs.draft {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_GitRepo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GitRepo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_GitRepo, rhs: Content_GitRepo) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "text"),
    5: .same(proto: "file"),
    6: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: Content_Text?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 5: try {
        var v: Content_File?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .file(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .file(v)
        }
      }()
      case 6: try {
        var v: Content_URL?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .url(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .url(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .file?: try {
      guard case .file(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .url?: try {
      guard case .url(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Data, rhs: Content_Data) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Normalized: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Normalized"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "article"),
    4: .same(proto: "html"),
    6: .same(proto: "transcript"),
    7: .same(proto: "readme"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try {
        var v: Content_Article?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .article(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .article(v)
        }
      }()
      case 4: try {
        var v: Content_HTML?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .html(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .html(v)
        }
      }()
      case 6: try {
        var v: Content_Transcript?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .transcript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .transcript(v)
        }
      }()
      case 7: try {
        var v: Content_ReadMe?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .readme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .readme(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .article?: try {
      guard case .article(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .html?: try {
      guard case .html(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .transcript?: try {
      guard case .transcript(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .readme?: try {
      guard case .readme(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Normalized, rhs: Content_Normalized) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Transformed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transformed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "summary"),
    2: .same(proto: "categories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Content_Summary?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .summary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .summary(v)
        }
      }()
      case 2: try {
        var v: Content_Categories?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .categories(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .categories(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .summary?: try {
      guard case .summary(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .categories?: try {
      guard case .categories(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Transformed, rhs: Content_Transformed) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Article: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Article"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "author"),
    3: .same(proto: "length"),
    4: .same(proto: "excerpt"),
    5: .standard(proto: "site_name"),
    6: .same(proto: "image"),
    7: .same(proto: "favicon"),
    8: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.author) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.excerpt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.siteName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.image) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.favicon) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 3)
    }
    if !self.excerpt.isEmpty {
      try visitor.visitSingularStringField(value: self.excerpt, fieldNumber: 4)
    }
    if !self.siteName.isEmpty {
      try visitor.visitSingularStringField(value: self.siteName, fieldNumber: 5)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 6)
    }
    if !self.favicon.isEmpty {
      try visitor.visitSingularStringField(value: self.favicon, fieldNumber: 7)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Article, rhs: Content_Article) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.author != rhs.author {return false}
    if lhs.length != rhs.length {return false}
    if lhs.excerpt != rhs.excerpt {return false}
    if lhs.siteName != rhs.siteName {return false}
    if lhs.image != rhs.image {return false}
    if lhs.favicon != rhs.favicon {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_HTML: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HTML"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "html"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.html) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.html.isEmpty {
      try visitor.visitSingularStringField(value: self.html, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_HTML, rhs: Content_HTML) -> Bool {
    if lhs.html != rhs.html {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_ReadMe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadMe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_ReadMe, rhs: Content_ReadMe) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Summary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Summary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Summary, rhs: Content_Summary) -> Bool {
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Categories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Categories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "categories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.categories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.categories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categories, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Categories, rhs: Content_Categories) -> Bool {
    if lhs.categories != rhs.categories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    2: .same(proto: "data"),
    3: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_File, rhs: Content_File) -> Bool {
    if lhs.file != rhs.file {return false}
    if lhs.data != rhs.data {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Text, rhs: Content_Text) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_URL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".URL"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "crawl"),
    3: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.crawl) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.crawl != false {
      try visitor.visitSingularBoolField(value: self.crawl, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_URL, rhs: Content_URL) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.crawl != rhs.crawl {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Token"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "end_time"),
    4: .same(proto: "text"),
    5: .same(proto: "p"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.endTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 2)
    }
    if self.endTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.endTime, fieldNumber: 3)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 4)
    }
    if !self.p.isEmpty {
      try visitor.visitSingularStringField(value: self.p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Token, rhs: Content_Token) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.text != rhs.text {return false}
    if lhs.p != rhs.p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Segment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "tokens"),
    3: .same(proto: "text"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.num) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.startTime) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.num != 0 {
      try visitor.visitSingularUInt32Field(value: self.num, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 4)
    }
    if self.endTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.endTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Segment, rhs: Content_Segment) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.text != rhs.text {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Transcript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transcript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "segments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Transcript, rhs: Content_Transcript) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_GRPCTypeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GRPCTypeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    3: .standard(proto: "desc_lookup"),
    4: .standard(proto: "enum_lookup"),
    6: .standard(proto: "package_name"),
  ]

  public var isInitialized: Bool {
    if let v = self._msg, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.descLookup) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.enumLookup) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._msg) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_DescriptorProto>.self, value: &self.descLookup) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_EnumDescriptorProto>.self, value: &self.enumLookup) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.packageName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.descLookup.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_DescriptorProto>.self, value: self.descLookup, fieldNumber: 3)
    }
    if !self.enumLookup.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_EnumDescriptorProto>.self, value: self.enumLookup, fieldNumber: 4)
    }
    if !self.packageName.isEmpty {
      try visitor.visitSingularStringField(value: self.packageName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_GRPCTypeInfo, rhs: Content_GRPCTypeInfo) -> Bool {
    if lhs._msg != rhs._msg {return false}
    if lhs.descLookup != rhs.descLookup {return false}
    if lhs.enumLookup != rhs.enumLookup {return false}
    if lhs.packageName != rhs.packageName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_Site: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Site"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hugo_config"),
    2: .standard(proto: "post_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hugoConfig) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.postTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hugoConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.postTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.postTags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_Site, rhs: Content_Site) -> Bool {
    if lhs._hugoConfig != rhs._hugoConfig {return false}
    if lhs.postTags != rhs.postTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_HugoConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HugoConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "theme"),
    2: .standard(proto: "base_url"),
    3: .same(proto: "title"),
    4: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.theme) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.theme.isEmpty {
      try visitor.visitSingularStringField(value: self.theme, fieldNumber: 1)
    }
    if !self.baseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.baseURL, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_HugoConfig, rhs: Content_HugoConfig) -> Bool {
    if lhs.theme != rhs.theme {return false}
    if lhs.baseURL != rhs.baseURL {return false}
    if lhs.title != rhs.title {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_ParamsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParamsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "env"),
    2: .same(proto: "description"),
    3: .same(proto: "author"),
    4: .standard(proto: "default_theme"),
    5: .standard(proto: "show_share_buttons"),
    6: .standard(proto: "show_reading_time"),
    7: .standard(proto: "display_full_lang_name"),
    8: .standard(proto: "show_post_nav_links"),
    9: .standard(proto: "show_bread_crumbs"),
    10: .standard(proto: "show_code_copy_buttons"),
    11: .standard(proto: "show_rss_button_in_section_term_list"),
    12: .standard(proto: "show_all_pages_in_archive"),
    13: .standard(proto: "show_page_nums"),
    14: .standard(proto: "show_toc"),
    15: .same(proto: "images"),
    16: .standard(proto: "profile_mode"),
    17: .standard(proto: "home_info_params"),
    18: .standard(proto: "social_icons"),
    19: .standard(proto: "edit_post"),
    20: .same(proto: "assets"),
  ]

  fileprivate class _StorageClass {
    var _env: String = String()
    var _description_p: String = String()
    var _author: String = String()
    var _defaultTheme: String = String()
    var _showShareButtons: Bool = false
    var _showReadingTime: Bool = false
    var _displayFullLangName: Bool = false
    var _showPostNavLinks: Bool = false
    var _showBreadCrumbs: Bool = false
    var _showCodeCopyButtons: Bool = false
    var _showRssButtonInSectionTermList: Bool = false
    var _showAllPagesInArchive: Bool = false
    var _showPageNums: Bool = false
    var _showToc: Bool = false
    var _images: [String] = []
    var _profileMode: Content_ProfileModeConfig? = nil
    var _homeInfoParams: Content_HomeInfoParamsConfig? = nil
    var _socialIcons: [Content_SocialIconConfig] = []
    var _editPost: Content_EditPostConfig? = nil
    var _assets: Content_AssetsConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _env = source._env
      _description_p = source._description_p
      _author = source._author
      _defaultTheme = source._defaultTheme
      _showShareButtons = source._showShareButtons
      _showReadingTime = source._showReadingTime
      _displayFullLangName = source._displayFullLangName
      _showPostNavLinks = source._showPostNavLinks
      _showBreadCrumbs = source._showBreadCrumbs
      _showCodeCopyButtons = source._showCodeCopyButtons
      _showRssButtonInSectionTermList = source._showRssButtonInSectionTermList
      _showAllPagesInArchive = source._showAllPagesInArchive
      _showPageNums = source._showPageNums
      _showToc = source._showToc
      _images = source._images
      _profileMode = source._profileMode
      _homeInfoParams = source._homeInfoParams
      _socialIcons = source._socialIcons
      _editPost = source._editPost
      _assets = source._assets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._env) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._author) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._defaultTheme) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._showShareButtons) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._showReadingTime) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._displayFullLangName) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._showPostNavLinks) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._showBreadCrumbs) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._showCodeCopyButtons) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._showRssButtonInSectionTermList) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._showAllPagesInArchive) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._showPageNums) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._showToc) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._images) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._profileMode) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._homeInfoParams) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._socialIcons) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._editPost) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._assets) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._env.isEmpty {
        try visitor.visitSingularStringField(value: _storage._env, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularStringField(value: _storage._author, fieldNumber: 3)
      }
      if !_storage._defaultTheme.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultTheme, fieldNumber: 4)
      }
      if _storage._showShareButtons != false {
        try visitor.visitSingularBoolField(value: _storage._showShareButtons, fieldNumber: 5)
      }
      if _storage._showReadingTime != false {
        try visitor.visitSingularBoolField(value: _storage._showReadingTime, fieldNumber: 6)
      }
      if _storage._displayFullLangName != false {
        try visitor.visitSingularBoolField(value: _storage._displayFullLangName, fieldNumber: 7)
      }
      if _storage._showPostNavLinks != false {
        try visitor.visitSingularBoolField(value: _storage._showPostNavLinks, fieldNumber: 8)
      }
      if _storage._showBreadCrumbs != false {
        try visitor.visitSingularBoolField(value: _storage._showBreadCrumbs, fieldNumber: 9)
      }
      if _storage._showCodeCopyButtons != false {
        try visitor.visitSingularBoolField(value: _storage._showCodeCopyButtons, fieldNumber: 10)
      }
      if _storage._showRssButtonInSectionTermList != false {
        try visitor.visitSingularBoolField(value: _storage._showRssButtonInSectionTermList, fieldNumber: 11)
      }
      if _storage._showAllPagesInArchive != false {
        try visitor.visitSingularBoolField(value: _storage._showAllPagesInArchive, fieldNumber: 12)
      }
      if _storage._showPageNums != false {
        try visitor.visitSingularBoolField(value: _storage._showPageNums, fieldNumber: 13)
      }
      if _storage._showToc != false {
        try visitor.visitSingularBoolField(value: _storage._showToc, fieldNumber: 14)
      }
      if !_storage._images.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._images, fieldNumber: 15)
      }
      try { if let v = _storage._profileMode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._homeInfoParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._socialIcons.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._socialIcons, fieldNumber: 18)
      }
      try { if let v = _storage._editPost {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._assets {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_ParamsConfig, rhs: Content_ParamsConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._env != rhs_storage._env {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._defaultTheme != rhs_storage._defaultTheme {return false}
        if _storage._showShareButtons != rhs_storage._showShareButtons {return false}
        if _storage._showReadingTime != rhs_storage._showReadingTime {return false}
        if _storage._displayFullLangName != rhs_storage._displayFullLangName {return false}
        if _storage._showPostNavLinks != rhs_storage._showPostNavLinks {return false}
        if _storage._showBreadCrumbs != rhs_storage._showBreadCrumbs {return false}
        if _storage._showCodeCopyButtons != rhs_storage._showCodeCopyButtons {return false}
        if _storage._showRssButtonInSectionTermList != rhs_storage._showRssButtonInSectionTermList {return false}
        if _storage._showAllPagesInArchive != rhs_storage._showAllPagesInArchive {return false}
        if _storage._showPageNums != rhs_storage._showPageNums {return false}
        if _storage._showToc != rhs_storage._showToc {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._profileMode != rhs_storage._profileMode {return false}
        if _storage._homeInfoParams != rhs_storage._homeInfoParams {return false}
        if _storage._socialIcons != rhs_storage._socialIcons {return false}
        if _storage._editPost != rhs_storage._editPost {return false}
        if _storage._assets != rhs_storage._assets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_ProfileModeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileModeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "title"),
    3: .standard(proto: "image_url"),
    4: .standard(proto: "image_title"),
    5: .same(proto: "buttons"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.imageTitle) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.buttons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 3)
    }
    if !self.imageTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.imageTitle, fieldNumber: 4)
    }
    if !self.buttons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buttons, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_ProfileModeConfig, rhs: Content_ProfileModeConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.title != rhs.title {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.imageTitle != rhs.imageTitle {return false}
    if lhs.buttons != rhs.buttons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_ButtonConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ButtonConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_ButtonConfig, rhs: Content_ButtonConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_HomeInfoParamsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HomeInfoParamsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_HomeInfoParamsConfig, rhs: Content_HomeInfoParamsConfig) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_SocialIconConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SocialIconConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "title"),
    3: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_SocialIconConfig, rhs: Content_SocialIconConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.title != rhs.title {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_EditPostConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditPostConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "text"),
    3: .standard(proto: "append_file_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.appendFilePath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.appendFilePath != false {
      try visitor.visitSingularBoolField(value: self.appendFilePath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_EditPostConfig, rhs: Content_EditPostConfig) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.text != rhs.text {return false}
    if lhs.appendFilePath != rhs.appendFilePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Content_AssetsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disable_hljs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disableHljs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disableHljs != false {
      try visitor.visitSingularBoolField(value: self.disableHljs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Content_AssetsConfig, rhs: Content_AssetsConfig) -> Bool {
    if lhs.disableHljs != rhs.disableHljs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
