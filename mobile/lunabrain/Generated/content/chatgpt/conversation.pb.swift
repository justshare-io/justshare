// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: content/chatgpt/conversation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Chatgpt_Conversation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var createTime: Double = 0

  public var updateTime: Double = 0

  public var mapping: Dictionary<String,Chatgpt_Node> = [:]

  public var conversationID: String = String()

  public var conversationTemplateID: String = String()

  public var currentNode: String = String()

  public var gizmoID: String = String()

  /// moderation_results = []
  /// plugin_ids = null
  /// safe_urls = []
  public var isArchived: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var message: Chatgpt_Message {
    get {return _message ?? Chatgpt_Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var parent: String = String()

  public var children: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Chatgpt_Message? = nil
}

public struct Chatgpt_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var author: Chatgpt_Author {
    get {return _author ?? Chatgpt_Author()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {self._author = nil}

  /// Optional, based on usage in JSON
  public var createTime: Double = 0

  public var content: Chatgpt_Content {
    get {return _content ?? Chatgpt_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var status: String = String()

  /// Optional, based on usage in JSON
  public var endTurn: Bool = false

  public var weight: Int32 = 0

  public var metadata: Chatgpt_MessageMetadata {
    get {return _metadata ?? Chatgpt_MessageMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var recipient: String = String()

  public var updateTime: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _author: Chatgpt_Author? = nil
  fileprivate var _content: Chatgpt_Content? = nil
  fileprivate var _metadata: Chatgpt_MessageMetadata? = nil
}

public struct Chatgpt_MessageMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_Author {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: String = String()

  public var metadata: Chatgpt_AuthorMetadata {
    get {return _metadata ?? Chatgpt_AuthorMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Chatgpt_AuthorMetadata? = nil
}

public struct Chatgpt_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "text" or "dalle.text2im", prob others too
  public var contentType: String = String()

  /// TODO breadchris make this work for images
  /// google.protobuf.Value parts = 2;
  public var parts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_AuthorMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This message can be extended based on the different key-value pairs found in your JSON's metadata.
  /// For example:
  public var attachments: [Chatgpt_Attachment] = []

  /// Use string for timestamps to avoid precision issues, or use int64/uint64 if they represent epoch time.
  public var timestamp_: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_Attachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var mimeType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Chatgpt_Conversation: @unchecked Sendable {}
extension Chatgpt_Node: @unchecked Sendable {}
extension Chatgpt_Message: @unchecked Sendable {}
extension Chatgpt_MessageMetadata: @unchecked Sendable {}
extension Chatgpt_Author: @unchecked Sendable {}
extension Chatgpt_Content: @unchecked Sendable {}
extension Chatgpt_AuthorMetadata: @unchecked Sendable {}
extension Chatgpt_Attachment: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "chatgpt"

extension Chatgpt_Conversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Conversation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "create_time"),
    3: .standard(proto: "update_time"),
    4: .same(proto: "mapping"),
    5: .standard(proto: "conversation_id"),
    6: .standard(proto: "conversation_template_id"),
    7: .standard(proto: "current_node"),
    8: .standard(proto: "gizmo_id"),
    9: .standard(proto: "is_archived"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.createTime) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.updateTime) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Chatgpt_Node>.self, value: &self.mapping) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.conversationTemplateID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.currentNode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.gizmoID) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isArchived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.createTime != 0 {
      try visitor.visitSingularDoubleField(value: self.createTime, fieldNumber: 2)
    }
    if self.updateTime != 0 {
      try visitor.visitSingularDoubleField(value: self.updateTime, fieldNumber: 3)
    }
    if !self.mapping.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Chatgpt_Node>.self, value: self.mapping, fieldNumber: 4)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 5)
    }
    if !self.conversationTemplateID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationTemplateID, fieldNumber: 6)
    }
    if !self.currentNode.isEmpty {
      try visitor.visitSingularStringField(value: self.currentNode, fieldNumber: 7)
    }
    if !self.gizmoID.isEmpty {
      try visitor.visitSingularStringField(value: self.gizmoID, fieldNumber: 8)
    }
    if self.isArchived != false {
      try visitor.visitSingularBoolField(value: self.isArchived, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Conversation, rhs: Chatgpt_Conversation) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.updateTime != rhs.updateTime {return false}
    if lhs.mapping != rhs.mapping {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.conversationTemplateID != rhs.conversationTemplateID {return false}
    if lhs.currentNode != rhs.currentNode {return false}
    if lhs.gizmoID != rhs.gizmoID {return false}
    if lhs.isArchived != rhs.isArchived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "message"),
    3: .same(proto: "parent"),
    4: .same(proto: "children"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.children) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 3)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedStringField(value: self.children, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Node, rhs: Chatgpt_Node) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._message != rhs._message {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "author"),
    3: .standard(proto: "create_time"),
    4: .same(proto: "content"),
    5: .same(proto: "status"),
    6: .standard(proto: "end_turn"),
    7: .same(proto: "weight"),
    8: .same(proto: "metadata"),
    9: .same(proto: "recipient"),
    10: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.endTurn) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.weight) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.updateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._author {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.createTime != 0 {
      try visitor.visitSingularDoubleField(value: self.createTime, fieldNumber: 3)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 5)
    }
    if self.endTurn != false {
      try visitor.visitSingularBoolField(value: self.endTurn, fieldNumber: 6)
    }
    if self.weight != 0 {
      try visitor.visitSingularInt32Field(value: self.weight, fieldNumber: 7)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 9)
    }
    if self.updateTime != 0 {
      try visitor.visitSingularDoubleField(value: self.updateTime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Message, rhs: Chatgpt_Message) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._author != rhs._author {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs._content != rhs._content {return false}
    if lhs.status != rhs.status {return false}
    if lhs.endTurn != rhs.endTurn {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.updateTime != rhs.updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_MessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_MessageMetadata, rhs: Chatgpt_MessageMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Author: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Author"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "metadata"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Author, rhs: Chatgpt_Author) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_type"),
    2: .same(proto: "parts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.parts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    if !self.parts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Content, rhs: Chatgpt_Content) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_AuthorMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthorMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachments"),
    2: .standard(proto: "timestamp_"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timestamp_) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 1)
    }
    if !self.timestamp_.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp_, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_AuthorMetadata, rhs: Chatgpt_AuthorMetadata) -> Bool {
    if lhs.attachments != rhs.attachments {return false}
    if lhs.timestamp_ != rhs.timestamp_ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Attachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "mimeType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Attachment, rhs: Chatgpt_Attachment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
