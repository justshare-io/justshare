// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: content/chatgpt/conversation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Chatgpt_Conversation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var createTime: Double = 0

  public var updateTime: Double = 0

  public var mapping: Dictionary<String,Chatgpt_Node> = [:]

  public var conversationID: String = String()

  public var conversationTemplateID: String = String()

  public var currentNode: String = String()

  public var gizmoID: String = String()

  /// moderation_results = []
  /// plugin_ids = null
  /// safe_urls = []
  public var isArchived: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var message: Chatgpt_Message {
    get {return _storage._message ?? Chatgpt_Message()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {_uniqueStorage()._message = nil}

  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  public var children: [String] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Chatgpt_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var author: Chatgpt_Author {
    get {return _author ?? Chatgpt_Author()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {self._author = nil}

  /// Optional, based on usage in JSON
  public var createTime: Double = 0

  public var content: Chatgpt_Content {
    get {return _content ?? Chatgpt_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var status: String = String()

  /// Optional, based on usage in JSON
  public var endTurn: Bool = false

  public var weight: Int32 = 0

  public var metadata: Chatgpt_MessageMetadata {
    get {return _metadata ?? Chatgpt_MessageMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var recipient: String = String()

  public var updateTime: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _author: Chatgpt_Author? = nil
  fileprivate var _content: Chatgpt_Content? = nil
  fileprivate var _metadata: Chatgpt_MessageMetadata? = nil
}

public struct Chatgpt_MessageMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_Author {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var role: String = String()

  public var metadata: Chatgpt_AuthorMetadata {
    get {return _metadata ?? Chatgpt_AuthorMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Chatgpt_AuthorMetadata? = nil
}

public struct Chatgpt_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "text" or "dalle.text2im", prob others too
  public var contentType: String = String()

  /// TODO breadchris make this work for images
  /// google.protobuf.Value parts = 2;
  public var textParts: [String] = []

  public var imageParts: [Chatgpt_ImageAsset] = []

  public var text: String = String()

  /// deprecated
  public var parts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_ImageAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contentType: String = String()

  public var assetPointer: String = String()

  public var sizeBytes: Int64 = 0

  public var width: Int32 = 0

  public var height: Int32 = 0

  public var fovea: Int32 = 0

  public var metadata: Chatgpt_Metadata {
    get {return _metadata ?? Chatgpt_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Chatgpt_Metadata? = nil
}

public struct Chatgpt_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dalle: Chatgpt_DalleMetadata {
    get {return _dalle ?? Chatgpt_DalleMetadata()}
    set {_dalle = newValue}
  }
  /// Returns true if `dalle` has been explicitly set.
  public var hasDalle: Bool {return self._dalle != nil}
  /// Clears the value of `dalle`. Subsequent reads from it will return its default value.
  public mutating func clearDalle() {self._dalle = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dalle: Chatgpt_DalleMetadata? = nil
}

public struct Chatgpt_DalleMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genID: String = String()

  public var prompt: String = String()

  public var seed: UInt32 = 0

  public var serializationTitle: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_AuthorMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This message can be extended based on the different key-value pairs found in your JSON's metadata.
  /// For example:
  public var attachments: [Chatgpt_Attachment] = []

  /// Use string for timestamps to avoid precision issues, or use int64/uint64 if they represent epoch time.
  public var timestamp_: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Chatgpt_Attachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var mimeType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Chatgpt_Conversation: @unchecked Sendable {}
extension Chatgpt_Node: @unchecked Sendable {}
extension Chatgpt_Message: @unchecked Sendable {}
extension Chatgpt_MessageMetadata: @unchecked Sendable {}
extension Chatgpt_Author: @unchecked Sendable {}
extension Chatgpt_Content: @unchecked Sendable {}
extension Chatgpt_ImageAsset: @unchecked Sendable {}
extension Chatgpt_Metadata: @unchecked Sendable {}
extension Chatgpt_DalleMetadata: @unchecked Sendable {}
extension Chatgpt_AuthorMetadata: @unchecked Sendable {}
extension Chatgpt_Attachment: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "chatgpt"

extension Chatgpt_Conversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Conversation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "create_time"),
    3: .standard(proto: "update_time"),
    4: .same(proto: "mapping"),
    5: .standard(proto: "conversation_id"),
    6: .standard(proto: "conversation_template_id"),
    7: .standard(proto: "current_node"),
    8: .standard(proto: "gizmo_id"),
    9: .standard(proto: "is_archived"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.createTime) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.updateTime) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Chatgpt_Node>.self, value: &self.mapping) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.conversationTemplateID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.currentNode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.gizmoID) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isArchived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.createTime != 0 {
      try visitor.visitSingularDoubleField(value: self.createTime, fieldNumber: 2)
    }
    if self.updateTime != 0 {
      try visitor.visitSingularDoubleField(value: self.updateTime, fieldNumber: 3)
    }
    if !self.mapping.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Chatgpt_Node>.self, value: self.mapping, fieldNumber: 4)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 5)
    }
    if !self.conversationTemplateID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationTemplateID, fieldNumber: 6)
    }
    if !self.currentNode.isEmpty {
      try visitor.visitSingularStringField(value: self.currentNode, fieldNumber: 7)
    }
    if !self.gizmoID.isEmpty {
      try visitor.visitSingularStringField(value: self.gizmoID, fieldNumber: 8)
    }
    if self.isArchived != false {
      try visitor.visitSingularBoolField(value: self.isArchived, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Conversation, rhs: Chatgpt_Conversation) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.updateTime != rhs.updateTime {return false}
    if lhs.mapping != rhs.mapping {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.conversationTemplateID != rhs.conversationTemplateID {return false}
    if lhs.currentNode != rhs.currentNode {return false}
    if lhs.gizmoID != rhs.gizmoID {return false}
    if lhs.isArchived != rhs.isArchived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "message"),
    3: .same(proto: "parent"),
    4: .same(proto: "children"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _message: Chatgpt_Message? = nil
    var _parent: String = String()
    var _children: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _message = source._message
      _parent = source._parent
      _children = source._children
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._children) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 3)
      }
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._children, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Node, rhs: Chatgpt_Node) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._children != rhs_storage._children {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "author"),
    3: .standard(proto: "create_time"),
    4: .same(proto: "content"),
    5: .same(proto: "status"),
    6: .standard(proto: "end_turn"),
    7: .same(proto: "weight"),
    8: .same(proto: "metadata"),
    9: .same(proto: "recipient"),
    10: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.endTurn) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.weight) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.updateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._author {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.createTime != 0 {
      try visitor.visitSingularDoubleField(value: self.createTime, fieldNumber: 3)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 5)
    }
    if self.endTurn != false {
      try visitor.visitSingularBoolField(value: self.endTurn, fieldNumber: 6)
    }
    if self.weight != 0 {
      try visitor.visitSingularInt32Field(value: self.weight, fieldNumber: 7)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 9)
    }
    if self.updateTime != 0 {
      try visitor.visitSingularDoubleField(value: self.updateTime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Message, rhs: Chatgpt_Message) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._author != rhs._author {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs._content != rhs._content {return false}
    if lhs.status != rhs.status {return false}
    if lhs.endTurn != rhs.endTurn {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.updateTime != rhs.updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_MessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_MessageMetadata, rhs: Chatgpt_MessageMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Author: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Author"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "metadata"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Author, rhs: Chatgpt_Author) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Content"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_type"),
    2: .standard(proto: "text_parts"),
    3: .standard(proto: "image_parts"),
    4: .same(proto: "text"),
    5: .same(proto: "parts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.textParts) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.imageParts) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.parts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    if !self.textParts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.textParts, fieldNumber: 2)
    }
    if !self.imageParts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.imageParts, fieldNumber: 3)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 4)
    }
    if !self.parts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Content, rhs: Chatgpt_Content) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs.textParts != rhs.textParts {return false}
    if lhs.imageParts != rhs.imageParts {return false}
    if lhs.text != rhs.text {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_ImageAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageAsset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_type"),
    2: .standard(proto: "asset_pointer"),
    3: .standard(proto: "size_bytes"),
    4: .same(proto: "width"),
    5: .same(proto: "height"),
    6: .same(proto: "fovea"),
    7: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.assetPointer) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.fovea) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    if !self.assetPointer.isEmpty {
      try visitor.visitSingularStringField(value: self.assetPointer, fieldNumber: 2)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 5)
    }
    if self.fovea != 0 {
      try visitor.visitSingularInt32Field(value: self.fovea, fieldNumber: 6)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_ImageAsset, rhs: Chatgpt_ImageAsset) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs.assetPointer != rhs.assetPointer {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.fovea != rhs.fovea {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dalle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dalle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dalle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Metadata, rhs: Chatgpt_Metadata) -> Bool {
    if lhs._dalle != rhs._dalle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_DalleMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DalleMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gen_id"),
    2: .same(proto: "prompt"),
    3: .same(proto: "seed"),
    4: .standard(proto: "serialization_title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.genID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.seed) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serializationTitle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.genID.isEmpty {
      try visitor.visitSingularStringField(value: self.genID, fieldNumber: 1)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 2)
    }
    if self.seed != 0 {
      try visitor.visitSingularUInt32Field(value: self.seed, fieldNumber: 3)
    }
    if !self.serializationTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.serializationTitle, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_DalleMetadata, rhs: Chatgpt_DalleMetadata) -> Bool {
    if lhs.genID != rhs.genID {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.seed != rhs.seed {return false}
    if lhs.serializationTitle != rhs.serializationTitle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_AuthorMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthorMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachments"),
    2: .standard(proto: "timestamp_"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timestamp_) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 1)
    }
    if !self.timestamp_.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp_, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_AuthorMetadata, rhs: Chatgpt_AuthorMetadata) -> Bool {
    if lhs.attachments != rhs.attachments {return false}
    if lhs.timestamp_ != rhs.timestamp_ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chatgpt_Attachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "mimeType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chatgpt_Attachment, rhs: Chatgpt_Attachment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
